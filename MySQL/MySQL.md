* MyISAM与InnoDB区别

  在5.5之前,MyISAM是默认的数据库引擎,后来改成了InnoDB

  虽然MyISAM提供了大量特性,包括全文索引,空间函数等,但MyISAM不支持事务和行级锁,而且最大的缺陷是崩溃后无法安全恢复

* 什么是全文索引

  * 全文索引平时用的不多

  * 应用场景:通过数值比较,范围过滤等就可以完成绝大多数我们需要的查询,但是,如果希望通过关键字的匹配来进行查询过滤,那么就需要基于相似度的查询,而不是原来的精确数值比较.全文索引就是为这种场景设计的

  * 用like+%就可以实现模糊匹配了?为什么还要全文索引?

    * like+%在文本比较少的时候是合适的,但是对于大量的文本数据检索是不可想象的,全文索引在大量数据面前,能比like+%快N倍,但是全文索引可能存在精度问题

  * 全文索引5.6之前,只有MyISAM支持,在5.6之后,MyISAM和InnoDB全都支持全文索引

  * 只有字段数据类型为char,varchar,text及其系列才可以建全文索引

  * 语句

    * 在fulltext_test表上创建content_tag_fulltext索引

    ```mysql
    create fulltest index coutent_tag_fulltext
    	on fulltext_test(content,teg)
    ```

    * 删除fulltext_test表上的content_tag_fulltext索引

    ```mysql
    drop index content_tag_fulltext
    	on fulltext_test
    ```

    * 使用

    ```mysql
    select * from fulltext_test
    	where match(content,tag) against('xxx xxx');
    ```

* MyISAM与InnoDB的区别

  * 是否支持行级锁?
    * MYISAM只有表级锁
    * InnoDB支持表级锁和行级锁,默认为行级锁
  * 是否支持事务和崩溃后的安全恢复
    * MYISAM支持的性能,每次查询具有原子性,但是不支持事务
    * InnoDB提供事务支持,外部键等高级数据库功能,具有事务,回滚和崩溃修复能力
  * 是否支持外键
    * MyISAM不支持
    * InnoDB支持
  * 是否支持MVCC
    * MyISAM不支持
    * 支持,应对高并发事务,MVCC比单纯的加锁更高效

* 讲讲MVCC吧

  * MVCC只在`read_committed`和`repetable_read`两个隔离级别下工作

    * 为什么只在读提交和可重复读下工作?
      * 读未提交总是读取最新的数据行,而不是符合当前事务版本的数据行
      * 而序列化会对所有读取的行都加锁

  * 可以使用乐观锁和悲观锁来实现???

  * 可以认为MVCC是行级锁的一个变种,但是他在很多情况下,避免了加锁操作,因此开销更低,虽然实现机制有所不同,写操作也只锁定必要的行,应对高并发事务,MVCC比单纯的加锁更高效

  * InnoDB的MVCC是通过在每行记录后面保存两个三个隐藏字段来实现的

    * 哪三个字段?
      * 事务ID,回滚指针,DB_ROW_ID(随着新航插入而单调递增的行ID)

  * Undo log是MVCC事务特性的重要组成部分

    * 谈论一下Undolog?

      * undo默认被记录到系统表空间,5.6以后可以使用独立地undo表空间
      * undo记录的是老版本数据,当一个旧的事务需要读取时,为了读取到老版本的数据,需要顺着undo链找到满足其可见性的记录

      ....

* 索引

  * MyISAM
    
    * B+树叶子节点存储的是数据的地址,根据地址读取相应的数据记录,称为"非聚簇索引"
    
  * InnoDB
    * 本身就是索引文件,索引文件和数据分离,表数据文件本身就是一个索引,书的叶子节点data域保存了完整的数据记录,这个索引的key是数据表的**主键包含的整行字段的数据**,因此表数据文件本身就是主索引,称为"聚簇索引"
    * 而其余的索引均为辅助索引,辅助索引的data域存储的是主键值,再走一遍主索引,因此**不建议使用过长的字段作为主键**,**也不建议使用非单调的字段作为主键**
    
  * 为什么用索引?

    * 加快查询速度

  * 索引这么好,为什么不给表中每一个列都创建一个索引呢?

    * 索引也需要空间存储,索引过多也会占很多地方

  * 索引如何提高查询速度的?

    * 将无序的数据编程有序的

  * 使用索引的注意事项

    * 索引加在,需要经常搜索的列上,
    * 在经常需要排序的列上创建索引
    * 避免在where子句中对字段施加函数,会造成无法命中索引
    * 使用InnoDB时,尽量选择与业务无关的自增主键
    * 打算加索引的列设置为not null,否则导致引擎放弃使用索引进行全表扫描

  * Mysql索引常用的两种数据结构?

    * hash
    * b+tree

  * MyISAM和InnoDB实现BTree的方式区别

    * data存储数据记录的地址,非聚簇索引
    * data记录完整的一行数据,索引文件与数据文件分离,但是表数据文件本身就是一个索引结构,存储了一行完整的数据,成为聚簇索引,其他的都是辅助索引

  * 什么是覆盖索引?

    * 索引包含查询需要的所有字段

  * Mysql如何为表字段添加索引？

    1.添加PRIMARY KEY（主键索引）

    ```
    ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
    ```

    2.添加UNIQUE(唯一索引)

    ```
    ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
    ```

    3.添加INDEX(普通索引)

    ```
    ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
    ```

    4.添加FULLTEXT(全文索引)

    ```
    ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
    ```

    5.添加多列索引

    ```
    ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
    ```

* 事务

  * ACID

    * A,原子性,事务是最小的执行单位,不允许分割,
    * C,一致性,执行事务后,数据库从一个争取的状态变化到另一个正确的状态
    * I,隔离性,各个并发事务之间数据库是独立的
    * D,持久性,已提交事务做出的数据改变是持久的

  * 并发事务带来的问题

    * 脏读
    * 丢失修改
    * 不可重复读
    * 幻读
      * 不可重复读和幻读的区别
        * 值的变化和记录的数量变化

  * 事务隔离级别

    * 读未提交-脏读,不可重复读,幻读
    * 读提交-不可重复读,幻读
    * 可重复读-幻读(默认隔离级别)
      * 虽然大部分数据库隔离级别是读提交,但是**InnoDB的隔离级别是读提交,**命令`SELECT @@transaction_isolation;`
      * +-------------------------+
        | @@transaction_isolation |
        +-------------------------+
        | REPEATABLE-READ         |
        +-------------------------+
        1 row in set (0.00 sec)
      * 虽然隔离级别是可重复读,但是但是InnoDB使用的是Next-Key Lock锁算法,因此可以避免幻读,所以InnoDB存储引擎默认的可重复读已经完全可以保证事物的隔离性要求
      * InnoDB存储引擎在分布式事务下一般使用可串行化隔离级别
      * **间隙锁怎么实现的?**
    * 串行化

  * 锁!?!!!

    * InnoDB存储引擎的锁有几种?

      * 行锁
      * gap lock:间隙锁.锁一个范围,不包含记录本身-**阻止多个事务将记录插入同一范围,这会导致幻读问题的产生**
      * next-key lock:**record+gap lock**,**锁一个范围,包含记录本身,**为了解决Phantom Problem幻读问题???什么是Phantom Problem幻读问题??

      1. innodb对于行的查询使用next-key lock
      2. 当查询索引具有唯一属性时,将next-key lock降级为行锁

* 大表优化

  * 常见的优化措施

    1. **限定数据范围**

       - **禁止不带任何限制范围的查询语句!!!!!!!!!!!**

    2. **读写分离**

       - **数据库拆分方案,读多写少,主库写,从库读**

    3. **垂直分区**

       - **根据表的相关性进行拆分,**如果一个表既有用户登录信息又有用户基本信息,可以将用户表拆分成两个单独的表
       - 优缺点
         - 优点:可以使得列数据变小,查询时减少读取的Block数
         - 缺点:主键冗余?!-解决办法,在应用层用join来处理

    4. **水平分区**

       - 举个例子把200万行数据拆分成两个100万行,就叫水平分区

       - 由于拆出来的数据还在同一台机器上,对提升MySQL并发能力没有什么意义,所以最好分库

       - 优缺点

         - 优点:支持非常大的数据量存储
         - 缺点:分片事务难以解决,会带来逻辑,部署,和运维的各种复杂度

       - 数据库分片的两种常见方案

         - 客户端代理-分片逻辑在应用端,封装在jar包中,通过修改或者封装JDBC层来实现

           当当网的Sharding-JDBC,

         - 中间件代理-应用和数据之间加入代理层,分片逻辑统一维护在中间件服务中

           306的Atlas,网易的DDB

* 池化设计思想
  * 什么是池化设计思想?
    * 我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，比如抵消,获取资源的开销,创建线程的开销,获取远程连接的开销
  * 什么是数据库连接池?
    * 本质是一个socket连接,可以把数据库连接池看作维护的数据库连接的缓存,以便将来需要对数据库请求时可以重用这些连接
    * **在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**
  * 为什么需要数据库连接池?
    * 减少不必要的建立连接的开销
    * 减少用户等待建立与数据库连接的时间

* 分库分表
  * id主键如何处理?
    1. UUID不适合
    2. 数据库自增id,两台数据库设置不同不长来实现,需要独立部署数据库实例,成本高,有性能瓶颈
    3. 立用redis生成,性能好,灵活方便,不依赖数据库引入新组件,让系统更复杂
    4. 雪花算法Twitter的snowflake
  
* 一条SQL语句在MySql中如何执行的?

  * 查询语句(select)
    1. 连接器-先检查该语句是否有权限
    2. 分析器-词法分析,比如提取查询select所需表名所有的列,然后判断sql是否有语法错误
    3. 优化器-优化器根据自己的优化算法选择一个执行效率最好的方案
    4. 执行器-开始执行
    5. 引擎-进行权限校验,有权限就会调用数据库引擎接口,返回引擎的执行结果,如果没有,就会返回错误信息
  * 更新语句(delete,update,insert)
    1. .....先查询到张三这一条数据
    2. 拿到查询的语句,更新数据,调用引擎写入这一行数据
    3. InnoDB把数据保存在内存中,记录redolog,进入prepare状态,告诉执行器,执行完成了,随时可以提交
    4. 执行器收到通知后记录binlog,然后调用引擎接口,提交redo log为提交状态
    5. 更新完成
       - 如果极端情况下,两段式提交中的redolog处于prepare,binlog也写完了还没commit,突然重启了,怎么办?
         - 依赖于MySQL的处理机制
           - 判断redolog是否完整,如果完整,提交
           - 如果redolog只是预提交,不是commit状态,去判断binlg是否完整,如果完整提交redolog,不完整就回滚

* MySQL高性能优化规范建议

  * https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd

* SQL执行很慢的原因有哪些?

  * 大多数情况下正常,偶尔出现很慢
    * 数据库在刷新脏页,也就是把内存的数据通过redolog写入磁盘
      * 刷脏页的几种情况?
        1. redolog写满了
        2. 内存不够用了
        3. mysql认为系统"空闲的时候"
        4. MySQL正常关闭的时候
    * 执行语句遇到了锁,执行语句涉及到的表,别人再用
      * show processlist查看当前状态
  * 数据量不变的情况下,一直执行的很慢
    * 没用上索引
      1. 字段没有索引
         - 字段没有索引,只能走全表扫描了,会很慢
      2. 字段有索引,但是没有用到索引
         - 语句问题
           - select * from t where c - 1 = 1000;`这条语句字段左边是c-1,就不会走索引,数据库不会把c-1=1000优化成c=1000+1
    * 数据库自己选错了索引



























