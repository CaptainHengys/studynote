#### 1,MySql连接数据库

连接指定ip地址的端口号，角色为root ，-p为请求键入密码，不建议在-p后明文输入密码

```
mysql -h 127.0.0.1 -P 3306 -u root -p
```

#### 2，一条Sql语句的执行流程

客户端-server(连接器-请求缓存(基本不用)or分析器-优化器-执行器)-引擎

#### 3，Mysql的底层结构

MySql分为server与引擎，server是固定的，引擎是插件式的，常用的有MyISAM,InnoDB,Memory，MySql5.5.5后默认为InnoDB引擎，

server:

连接器：客户端使用TCP连接与连接器建立连接，连接器负责的就是获取权限，维持和管理连接

缓存：MySql8.0已废弃，里面存储的是sql语句与结果的key-value映射

由于数据库的变化更新快，缓存可能会因为时效立刻作废，举个例子，比如缓存中存储表A的pre的状态，当向表中插入新的数据后，由于数据不一致，缓存中的表A的查询数据会立刻作废

分析器：分析基本的sql语法是否正确

优化器：对sql语句进行优化，比如该用什么索引？

执行器： 会先判断是否有操作权限！然后再去执行



引擎：------

#### 4，查询数据库连接数

注意没有下划线，不是process_list

```
mysql> show processlist
```

```
mysql> show processlist;
+----+------+----------------+------+---------+------+-------+------------------+
| Id | User | Host           | db   | Command | Time | State | Info             |
+----+------+----------------+------+---------+------+-------+------------------+
|  2 | root | localhost:9718 | NULL | Query   |    0 | NULL  | show processlist |
+----+------+----------------+------+---------+------+-------+------------------+
1 row in set (0.05 sec)
```



在Command一栏中，如果是Sleep则表示当前连接的状态为空闲连接

如果客户端太长时间没动静，连接器会在默认8小时候断开，如果连接断开了，显然在发送请求之前是需要重新建立连接的

#### 5，数据库中的长连接和短连接

长连接：一次连接执行多次请求，如果后续仍有请求，仍然使用该连接

短连接： 一次链接可能只执行几条请求就会断开，后续请求需要重新建立连接

**这里的建议是尽量使用长连接**

显然长连接减少了连接建立的时间，但是当一个长连接请求过多时，会出现OOM被MySql强行杀掉，MySql异常重启了，解决方案有两个：

* 定时断开长连接，

* 在MySql5.7后可使用`mysql_reset_connection`,讲连接恢复到刚刚建立好连接的状态，并且不需要重连和身份验证

  

  **注：mysql_reset_connection不会用！**

   https://dev.mysql.com/doc/refman/5.7/en/mysql-reset-connection.html 

#### 6，数据库中的join

join&inner join：默认inner join 写作 join，可以理解为符合条件的交集

left join： 强制保留左侧数据，右侧如不存在则null

right join： 以右侧数据为基准，左侧不存在则null

full out join ： 全连接，左右皆有，不存在为null,可以理解为全集

```
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

既可以先拿ti.c=10后的数据，也可以先拿t2.d=20后的数据再去执行join，

#### 7，redo log与 bin log

* ##### 概念

在MySql的开始，server底部的引擎是MyISAM，MyISAM引擎不存在任何log，只有server层存在一个bin log，由于MySql引擎是插槽似的，所以新插入的引擎InnoDB中他自己写了一个redo log，其实说了这么多，简而言之一句话就是“

**server中是bin log，所有引擎都可以用，**

**插槽引擎中，InnoDB是redo log，MyISAM没有log，**

”

**redo log 是InnoDB独有的日志记录模块**，记录数据物理变化，在WAL（write-ahead-log）技术中，他是一种类似于缓存的存在，他记录下变化，先写日志，在写磁盘，因为频繁的从硬盘中变更数据会很慢，并且他是循环写的，当空间不够时，**会把原来的擦掉重新写**，而**binlog是追加写的，不会清理掉之前的数据，**

* ##### 区别

bin log: 记录的是逻辑变化，会把语句记录下来，`update T set name= "Jerry" where id=3`

redo log ：记录的是物理变化，比如T表的第三行name属性从Tom变成Jerry,

bin log 与redo log的写入方式，bin log是追加写入，redolog是循环写入，write_pos 和checkpoint之间是未写的字段，当write_pos写到头，checkpoint就得开始清理了

* ##### 有了redolog可以抛弃使用binlog吗？

不可以！

一是因为binlog是追加方式，它可以将数据真正的持久化，在数据库恢复时起到了重要的作用，而写入 redolog不具有这个功能，由于他是循环写入，所以会存在信息覆盖

二是redolog只有InnoDB特有！

* ##### 如何恢复数据库？

有了redolog，我们就可以先将数据库恢复到之前备份的状态，比如我们的数据库是三天一备份，redo log存储了从上次备份到我们现在状态的所有语句，我们就可以先将数据库恢复至备份状态，然后根据redo log中的内容逐句执行恢复到我们想要的状态

* ##### 两段式协议

在写入redo log 和 bin log 的问题上我们还有问题没有考虑，如果其中一个写入失败了会怎么样？

如果 先操作redo log写入成功，后操作bin log写入失败，那么我们在操作redo log恢复数据库时就会出现，redolog执行了一次相对于原来预想数据库状态的额外语句

如果先操作 bin log写入成功，后操作 redo log写入失败，那么在恢复数据库时，就会出现比我们预想的数据库结果少一条的状态！

所以使用两段式协议，在redo log先行写入后 变为prepare状态，在bin log写入后，状态变成 commit，将这个事务提交

我们想想这样如果发生crash会发生什么？

如果bin log写入失败，那么prepare的状态不会变化commit，也就是说redo log不会真正写入

如果 bin log写入成功，那么redo log状态变成commit，两者都成功写入 

#### 8,事务隔离

事务其实就是要保证一组数据库的操作要么全都成功要么全都失败，在MySql中，事务支持是在底层引擎实现的，然而MySql底层原生的MyISAM不支持事务，

事务有ACID四个特性，这里学习的是其中的I,隔离性



Sql的隔离级别有四种

* 读未提交：一个事务在处理修改数据时，即使未提交，别的事务也会看到变化
* 读提交：一个事务只能读到其他事务提交后的数据

* 可重复读：事务拿到数据的过程中，即使其他事务修改了数据，本事务能看到的仍然是开始时读到的数据
* 串行化：对一个数据，读加读锁，写加写锁，线性执行，如果冲突只能等待

实际上，数据的处理读取都是在一个视图上进行操作的，访问的时候以视图逻辑结果为准，

可重复读的情况下，视图是在事务刚开始的时候创建的

读提交，是在每个sql语句开始执行的时候创建的

读未提交，没有视图的概念，每次直接去数据的最新值

串行化，是直接加锁避免冲突访问的

#### 9，undo log

回滚日志，是MVCC版本控制的关键，他记录redolog相反的逻辑操作，使得一条记录会有多个版本的存在

那么什么时候删除呢？答案是，当不需要的时候才删除，系统判断当没有事务在需要这些回滚日志的时候，才给删掉

那么什么时候不需要了呢？答案是，当没有比日志存在更早的read,write操作后



#### 10，为什么尽量不使用长事务？(注意不是长连接,我们建议使用长连接!)

这个和undo log和mvcc有关，事务越长，当执行一次的时候，对应这一次的undo log就要越长，那么当mvcc多版本存在的时候，长事务会导致undolog特别大，有可能，redolog 20G，undolog却达到了200G

建议通过set autocommit=1,显示启动事务语句，避免使用长事务

这样开始语句是begin 或者start transaction,

配套的提交语句是commit,

提交语句并自动开始下一个语句是commit work and chain

回滚语句是rollback

这样不仅可以避免长事务，还可以明确区分每个语句是否处于事务中

你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。

```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

**当实际工作中，如何避免长事务？**

* set autocommit=1,切换到显示自动提交
* 查询innodb_trx表中事务的时间，超过60s警报

#### 11，数据库中的索引

* hash索引

  哈希索引是一种key-value形式的索引，由于存在哈希冲突的问题，所以当哈希冲突时，会拉出一个链表

  在查找的时候，再从链表头部开始查到尾部，一个一个对着比较

  显然，hash适合于nosql的形式，一一对应查找会很快，但是这样会产生hash索引的局限性，就是不适合范围查找，比如说，我要查找id100-200的信息，那我就需要计算每一个id的位置，然后再去查找？那么有没有办法解决这个问题呢？答案是有序数组

* 有序数组

  从名字就可以看出来，这种索引存储方式是有序数组，当范围查找的时候，用二分法查找开头，不断取数据，当数据达到临界的时候结束，所以他适用于范围查找，但是他有数组的弊端，就是插入和删除会很麻烦，所以它适用于不常更新的静态数据，比如根据身份证号查名字

* 二叉树

  如果使用二叉树查找也是logn的复杂度，但是如果一个100万的数据块，需要20层二叉树，一次查询走到树的叶子节点需要十九步，假设一步需要10ms,那么差一个数据需要190ms,显然这个时间有点长了，或许可以考虑N叉树

* N叉树

  N叉树，这里N取决于数据块的大小，对应一次从磁盘读取的数据块大小，InnoDB中他的大小大约是1200，当这个树高是4的时候，1200^3已经超过了17个亿 ，这样查询一个值最多访问三次磁盘就对应到了叶子节点上的值

* B+树

  他把每一个根的节点数据也向下传递了，每一个数据，向左指向比自己小的块，向右指向大于等于自己的块，也就是说，所有数据都在叶子节点里，和之前的数据存在于根也存在于叶子节点里是不一样的，并且叶子节点块也是相连的，这样当范围查询时，读完一个块，如果还没满足要求可以直接读到顺序的下一个叶子节点数据，而不用，再从根查询，现在B+树是常用的索引结构

#### 12，主键索引和非主键索引

​		因该尽量使用主键索引，如果使用非主键查询，要先非主键索引，找到对应的主键，然后在进行主键索引

​		也就是说，主键索引查一次，非主键索引查两次	

​		**并且尽量使用自增主键，**

​		举个例子，如果身份证号作为主键，那么，每个叶子要占20字节大小，如果使用自增字段做主键，或许只占4		个字节到8个字节大小，这样来看，自增字段占用的存储空间会更小

​		**那么什么时候不能使用自增主键呢？**

- 只有一个索引

- 并且**该索引必须是唯一索引**

  这是**典型的K-V场景**，由于只存在一个索引，所以这里就不考虑自增字段，并且应该把主键当作索引，来避免二次查找	

#### 13，回表和覆盖索引

​		其实上一个问题谈到的，非主键索引查两次，就涉及到了回表，举个例子

​		如果执行的是`select * from T where k between 3 and 5`，，在K的索引上找到ID，然后回表查询*所有信息，这是回表

​		如果执行的是 `select ID from T where k between 3 and 5` ，ID是主键的话，那么此时在k的索引上就可以直接查出来，

​		我们把k的索引就叫做覆盖索引，这是一个最简单的覆盖索引

#### 14，联合索引，最左前缀原则，索引下推原则

​		如果像上面一样，为了方便，而给每一个查询都建立覆盖索引，那么需要建立的覆盖索引会很多，所以用联合索引会更方便

比如（name,money）,并且Innodb也是支持联合索引的，这样就不需要建立name索引了，直接使用name和money的联合索引就可以了，一般来说如果建立了（a,b）索引，那么就不需要建立a索引了，

但是如果需要b的话，b仍需建立索引

再说一说建立联合索引的部分原则

* 如果通过调换联合索引里的元素顺序可以少维护一个索引，那么应该尽力调换
* 还应考虑数据大小的问题，比如（age,name）联合索引，如果满足了上个要求，由于name的字段较大，当需要name作为单独索引的时候会占用较大空间，所以调换顺序，(name,age)，这样当需要age作为单独索引时，占用的空间会更小，



下面来想另一个问题，假设有（name,age）这个联合索引，当联合索引的某个条件不符合了该怎么办？

假设索引中是这个样子

| name | age  | id   |
| ---- | ---- | ---- |
| 张二 | 20   | 1    |
| 张三 | 10   | 2    |
| 张三 | 20   | 3    |

我要执行select * from tableT wher name like "张%" and age=10;

在MySql5.6之前

当执行到张二的时候，我们知道它满足于张%的要求，拿到id回表，再一一比较

在MySql5.6之后

引进**了索引下推，会对索引中包含的字段先做判断，张二符合条件，但是age不符合，所以不回表**，张三符合，10符合所以回表，张三符合，20不符合，所以不回表

#### 15，普通索引和唯一索引

**查询过程**

举个例子如果查询id为4

* 普通索引：找到id为4后仍需不断判断和查询，一直找到id为5不满足条件再结束

* 唯一索引：由于索引的唯一性，找到第一个id为4，就直接退出返回了

* 性能比较：两者的性能相差几乎是微乎其微，即使普通索引仍需要不断的判断，因为innodb的读取按照页来读取，这个页大小默认为16kb，所以数据都存在页里，即使读到页尾还没有读完数据的情况也是很少的

**更新过程**

如果页在内存里，那么会直接对页进行操作，如果不在内存里会存到change buffer。在后面会执行merge操作，在访问这个页会触发merge,系统后台也会定期merge,在数据库正常关闭也会执行merge

对于唯一索引，由于需要判断插入索引是否存在会从内存中读取，既然已经读取页了，那就不如直接更新内存，也就没必要使用change buffer了

对于普通索引，他会把更新操作缓存在change buffer中，



如果页不在内存，唯一索引需要读入内存，然后判断没有冲突，插入

普通索引只需要把更新操作缓存在change buffer中，

如果页在内存，唯一索引判断冲突，插入

普通索引只需要把更新操作缓存在change buffer中

change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50% 

并不是changebuffer适用于普通索引的任何情况，他适用于写多读少，而不适用于写少读多，写多都少merge前处理的更新操作会更多，效率会更高



所以在普通索引和唯一索引的选择中，建议尽量使用普通索引，效率会更高



#### 16,全局锁

顾名思义,全局锁对整个数据库加锁,MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。

**全局锁的经典使用场景是,做全库逻辑备份**

但是让整个库都只读,听上去就危险,

* 如果在主库上备份,那么业务直接停摆
* 如果在从库备份,那么备份期间就不能同步主库传来的binlog,会导致主从延迟



**对于全部是InnoDB引擎的库，我建议你选择使用–single-transaction参数，对应用会更友好。**



**那么为什么不在可重复读隔离级别下开启一个事务呢?**

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。**一致性读是好，但前提是引擎要支持这个隔离级别**,比如MYISAM就不支持事务,他是不支持事务的引擎,如果使用MYISAM,如果备份过程中有更新,总是只能取到最新的数据

**既然要全库只读，为什么不使用set global readonly=true的方式呢**？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：

- 一是，在有**些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库**。因此，修改global变量的方式影响面更大，我不建议你使用。
- 二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。

#### 17,表级锁

mysql的表级别锁有两种,一种是表锁,一种是元数据锁

**表锁的语法是 lock tables … read/write。**与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

**另一类表级的锁是MDL（metadata lock)。**MDL不需要显式使用，在访问一个表的时候会被**自动**加上。MDL的作用是，保证读写的正确性。

事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。所以很有可能因为一个读写锁的冲突,后续全都阻塞数据库直接爆掉



#### 18,行级锁

innodb特有,innodb的行级锁默认使用next-key lock,是record key和gap key的共同使用,可以一定程度解决幻读,因为gapkey锁住了一个范围,禁止多事务同时操作范围内数据,所以自然next-key lock也可以防止幻读



#### 19,一个 SQL 执行的很慢，我们要分两种情况讨论：

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

(3),查询的范围太大了,尽量不要用*

(4),像or.union这种交给数据库处理的,我们可以人为干预



#### 20,mysql为什么有时候选错索引?

在之前提到过,选择索引是优化器的工作,扫描行数是影响代价的因素之一,扫描的行数越少,意味着访问磁盘数据的次数越少,消耗的CPU资源越少

当然,扫描行数不是唯一的判断标准,优化器还会结合是否使用临时表,是否排序等因素进行综合判断

**扫描行数是怎么判断的?**

Mysql在真正执行语句之前并不精确的直到满足条件的记录有多少条,而只能根据统计信息来估算记录数

而这个统计信息就是**索引的区分度**

显然,一个索引上不同的值越多,这个索引的区分度就越好,一个索引上不同的值的个数,我们称为基数,也就是说,基数越大,索引的区分度越好

可以使用show index form table_t来看索引的基数(explain是查询语句走的索引)

MySQL获取索引基数的方式----采样统计的方法

为什么要采样统计呢,因为把整张表取出来一行行计算,虽然精确但是代价太高

采样统计的时候,InnoDB默认会选择N个数据页,统计这些页面上的不同值,得到一个平均值,然后乘这个索引的页面数,来得到索引基数

而数据库表会持续更新,所以索引统计信息也不会固定不变,所以当变更的数据行数超过/M的时候,会自动触发重新做一次索引统计

另外由于使用**普通索引需要计算回表的代价**,所以explain估算语句执行的rows时,即使普通索引的行数少于主键索引,**仍然会选择主键索引**

如果发现索引统计信息偏差严重,可以使用analyze table_t;来重新统计索引信息

**索引选择异常和处理**

* (不建议使用)如果总是没走到争取的索引,可以force index强行选择一个索引

* 尝试修改语句,引导MySQL使用我们期望的索引,比如select b order by b limit 1,即使b有10000行,但是因为他是主键索引,也会直接使用,如果改成select b order by b,a limit 1,那么这个时候对b,a都进行了排序,行数成为了影响决策的主要条件
* 建一个更合适的索引,但是很难



#### 给字符串字段加索引

考虑维护一个邮箱系统,那么避免不了select id,name form table_t where email='24301xxxxx@163.com'这种语句

如果不加索引,那么走全文索引

或许可以试试前缀索引

alter table SUser add index index2(email(6));

如果全文索引,那么找到满足索引值的记录,去主键上拿一行数据,对比email是否正确,直接加入结果集

如果前缀索引,那么找到满足索引值的记录,去主键上拿一行数据,对比email不正确,那么需要回到前缀索引,继续查询,所以!有可能前缀索引虽然减小了占用空间,但是可能会增加额外的记录扫描次数

**所以定义好长度,就能做到既节省空间,又不用额外增加太多的查询成本**

所以在设置的时候,区分度很重要!!,区分度越高越方便

另外-**覆盖索引**,如果用了前缀索引,虽然前缀索引包含了所有信息,但是InnoDB仍然需要回到id索引再查一下,因为系统并不确定前缀索引的定义是否截断了完整信息



解决办法?

- 倒叙存储,比如身份证号,前6位地址码,同一个地区的人基本相同,那么不如倒叙存储,后6位几乎没有重复逻辑,用来绕过字符串本身前缀区分度不够的问题

* hash值,可以新建一个整数字段,保存身份证的校验码(hash),同时在这个字段上创建索引,查询性能稳定,但是有额外的存储和计算消耗
* 

缺点!:范围查找不能实现了



































20,为什么不建议使用过长的字段作为主键?

21,为什么选择自增字段作为主键?

22,为什么常更新字段不建议建立索引

23,为什么选择区分度高的列作为索引,

24,尽可能使用覆盖索引

25,哪些情况下不会走索引?or需要每个字段都有索引,where中出现数学计算,查询条件出现!=判断,非前缀使用like

26,如何优化一条sql,**对语句的优化**,比如将子查询改为join,**对索引的优化**,上面四点,避免or,避免where中出现数学函数,避免!=避免非前缀出现like模糊查询,**尽量使用**覆盖索引,优化范围,优化表的类型结构

















































